\chapter{Orthogonal Arrays in Monte Carlo Integration}

Now that we understand how to construct orthogonal arrays, we can apply some
transformations to them so they can be used effectively in Monte Carlo
integration as a sampler. Veach, in his thesis, briefly mentioned OAs for use in
rendering \cite{Veach:1998:Robust}. As far as we know, OAs have not been
explored in Monte Carlo integration in the context of computer graphics. \\

We can normalize the points generated by an orthogonal array so that they fit
within the domain for Monte Carlo sampling. We can also translate some of the
terms used to describe OAs so that they make sense in the context of Monte Carlo
integration. The number of runs in an orthogonal array is analogous to the total
number of points in a point set, the factors are equivalent to the
dimensionality of the point set, and the levels are analogous to the number of
large strata used when sampling.

\section{Owen's Transformations}

\begin{figure}
    \centering
    \includegraphics[scale=0.2]{figures/oas-no-shuffle.pdf}
    \caption[An OA with no randomization]{An OA with no randomization,
        highlighting the ``planar flaw'' \cite{ours}}
    \label{fig:oa-no-shuffle}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.2]{figures/oas-shuffle.pdf}
    \caption{A randomized OA \cite{ours}}
    \label{fig:oa-shuffle}
\end{figure}

Owen demonstrates a simple transformation that can be applied to points of an
orthogonal array to make them suitable for Monte Carlo integration. This mostly
entails randomizing them, normalizing them, and jittering them within strata. \\

It is crucial to randomize the orthogonal arrays, otherwise the points align
along several planes, something that is referred to as the ``planar flaw''
\cite{Owen:2013:Monte}. Refer to Figure~\ref{fig:oa-no-shuffle} to see what the
canonical arrangement of the Bose construction looks like, and compare with
Figure~\ref{fig:oa-shuffle} to see what the OA looks like once randomized. \\

Owen defines the randomized, jittered, and normalized arrangement of an OA as
such:

\begin{equation}
    X_{ij} = \frac{\pi_j(A_{ij}) + U_{ij}}{b}
\end{equation}

\noindent
where $1 \leq i \leq n$ and $1 \leq j \leq d$ \cite{Owen:2013:Monte}. $\pi_1
\cdots \pi_d$ are defined as random permutations of the indices of the OA. In
essence, this equation shuffles the points of an orthogonal array, jitters the
points within their strata, and then normalizes them so that they fall within
the $[0, 1)$ unit domain (per each dimension). \\

There are still improvements that can be made. For example, none of the
shuffling in this transformation of the OA is correlated, and we do not meet the
Latin hypercube/N-rooks constraint, which would improve the sampler's
performance in Monte Carlo integration.

\section{Practical Construction Algorithms}

In this section, we aim to provide practical construction techniques for
generating point sets that use the transformation provided by Owen. With these
algorithms, we aim to be efficient, which entails low memory and computational
requirements. These implementations are in-place, which means that any index and
dimension of a sampler can be generated without requiring knowledge of other
points, which lends itself to low memory overhead.  Of course, this introduces
some added complexity - how do we know where to place a point so that it meets
strict stratification requirements and maintain the N-rooks guarantee if we
don't know where the other points are positioned?  In this section, we will
explain how we can achieve that while presenting examples of code that we used
to generate orthogonal array based point sets. \\

\subsection{Background Listings}

In this section, we will introduce some code snippets that will be used
throughout this paper. These are useful snippets of code that we have either
constructed or derived from other works.

\begin{minted}{cpp}
/*!
 * \brief Permute a number
 *
 * \param i The number to permute/the index of the permutation vector
 * \param l The desired size of the permutation vector
 * \param p The seed of the shuffle
 */
unsigned permute(unsigned i, unsigned l, unsigned p) {
  unsigned w = l - 1;
  w |= w >> 1;
  w |= w >> 2;
  w |= w >> 4;
  w |= w >> 8;
  w |= w >> 16;

  do {
    i ^= p;
    i *= 0xe170893d;
    i ^= p >> 16;
    i ^= (i & w) >> 4;
    i ^= p >> 8;
    i *= 0x0929eb3f;
    i ^= p >> 23;
    i ^= (i & w) >> 1;
    i *= 1 | p >> 27;
    i *= 0x6935fa69;
    i ^= (i & w) >> 11;
    i *= 0x74dcb303;
    i ^= (i & w) >> 2;
    i *= 0x9e501cc3;
    i ^= (i & w) >> 2;
    i *= 0xc860a3df;
    i &= w;
    i ^= i >> 5;
  } while (i >= l);
  return (i + p) % l;
}
\end{minted}

\noindent
The \verb|permute| function is method that produces an in-place or hashed
permutation. It is equivalent to creating a list of $l$ elements, and shuffling
each element around, and retrieving the $i^{th}$ element in that list. This
function is taken from Kensler's technical report
\cite{Kensler:2013:Correlated}.

\begin{minted}{cpp}
float randfloat(unsigned i, unsigned p) {
    i ^= p;
    i ^= i >> 17;
    i ^= i >> 10;       i *= 0xb36534e5;
    i ^= i >> 12;
    i ^= i >> 21;       i *= 0x93fc4795;
    i ^= 0xdf6e307f;
    i ^= i >> 17;       i *= 1 | p >> 18;
    return i * (1.0f / 4294967808.0f);
}
\end{minted}

\noindent
\verb|randfloat| is an efficient function that generates a random number.

\subsection{(Correlated) Multi-Jittering in 2D Projections}

We have already discussed the Bose construction techniques. We propose a slight
modification of the technique in order to allow for correlated multi-jittering,
as was described by \citeauthor{Kensler:2013:Correlated}, but in a manner that
extends these properties to a higher-dimensional point set. \\

When constructing the first two columns of the point set, the Bose construction,
as described by Equation~\eqref{eq:bose-first-col-construction} and
Equation~\eqref{eq:bose-second-col-construction}, essentially takes the index
and breaks it down into its base $p$ representation. The implication of using a
base representation means that every index will yield unique strata. This is the
key to being able to select strata in-place while ensuring that every point
lands in different strata. We know that any two numbers $a$ and $b$, such that
$a \neq b$, will yield representations in any base such that $a$ and $b$ have
different representations. In short, this means that different indices yield
different combinations of strata. \\

This is a good start, because we have well-stratified points with respect to the
coarse strata in the domain (there are $p$ strata in each dimension), but we
also want to maintain the N-rooks constraint, as well as multi-jittered, and
correlated multi-jittered offsets. Within each of the $p$ strata, there are $p$
additional substrata in each dimension. The key to achieving the proper offsets
is to select the correct substrata once a coarse stratum has been selected. Our
strategy for selecting offsets entails using the stratum from another dimension
to inform what the stratum ought to be for the current dimension. \\

In order to implement simple jittering, we can choose a substratum at random by
permuting the index through all of the available substrata. This ensures that we
pick a unique substratum for each point to meet the N-rooks constraint, but does
not provide any correlation. If we want multi-jittered (MJ) sampling, we can be
a bit more clever when choosing the offset function. We can permute through the
substrata based on the coarse strata selected by some other dimension. For the
first two dimensions, we base the substrata of the x dimension on the coarse
stratum of the y dimension. For higher dimensions, we simply need a consistent
method of selecting a stratum from another dimension. \\

We introduce a further complication in order to implement correlated-multi
jittered (CMJ) sampling with respect to selecting the other dimension. We only
enforce the CMJ constraint for ``primary'' pairs of dimensions, such as $(0,
1)$, $(2, 3)$, etc. This means that all of the cross-dimensional projections of
the point set do not get the CMJ stratification. Instead, we perform the MJ
offset for the cross-dimensional projections. For the CMJ offset, we select the
same substrata based off of the coarse strata for every dimension, so that the
shuffles within CMJ-enabled dimensions are identical, as implemented in the
original 2D variant of CMJ \cite{Kensler:2013:Correlated}.

\begin{minted}{cpp}
    float boseOA(int i, int j, int s, int p, Offset ot) {
        int Aij, Aik;
        i              = permute(i % (s*s), N, p * 0x51633e2d);
        int Ai0        = i % s;
        int Ai1        = i / s;
        if (j == 0) {
            Aij        = Ai0;
            Aik        = Ai1;
        } else if (j == 1) {
            Aij        = Ai1;
            Aik        = Ai0;
        } else {
            int k      = (j % 2) ? j-1 : j+1;
            Aij        = (Ai0 + (j-1) * Ai1) % s;
            Aik        = (Ai0 + (k-1) * Ai1) % s;
        }
        int stratum    = permute(Aij, s, p);
        int subStratum = offset(Aij, Aik, s, p * 0x68bc21eb, ot);
        float jitter   = randfloat(i, p * 0x02e5be93);
        return (stratum + (subStratum + jitter) / s) / s;
    }

    // Compute substrata offsets
    int offset(int sx, int sy, int s, int p, OffsetType ot) {
        if (ot == J)   return permute(0, s, (sy * s + sx + 1) * p);
        if (ot == MJ)  return permute(sy, s, (sx + 1) * p);
        return permute(sy, s, p);   // Defaults to CMJ
    }
\end{minted}

\noindent
The code listing above demonstrates an implementation of Bose in-place with
selectable jittered, multi-jittered, and correlated-multi jittered offsets.

\subsection{(Multi-)Jittering in t-D Projections}

The Bush construction allows us to select an arbitrary strength ($t$), which
equates to an arbitrary stratification guarantee. Where Bose was restricted to
strength 2, and thus can only be stratified in 2D projections, the Bush
construction allows us to expand beyond two dimensions and stratify in
any $t$-dimensional projection. \\

The basic strategy is similar to what we did for the Bose construction. We first
select a coarse stratum based on the index of the sample re-interpreted in base
$p$. We then select a substratum by assigning a new unique index from the
original index. In this case, we elected to make the new index $i / p \bmod p^{t
    - 1}$. Another transformation can be used, as long as every sample that
falls into the same strata receives a unique index so we can ensure they all
fall in different substrata. The standard jittering approach remains the same as
before - select a random substratum for each sample.

\begin{minted}{cpp}
    float bushOA(int i, int j, int s, int t, int p, Offset ot) {
        int N          = pow(s, t);
        i              = permute(i, N, p * 0x51633e2d);
        auto iDigits   = toBaseS(i, s, t);
        int stm        = N / s;     // s^(t-1)
        int k          = (j % 2) ? j - 1 : j + 1;
        int phi        = evalPoly(iDigits, j);
        int stratum    = permute(phi % s, s, p);
        int subStratum = offset(i, s, stm, p * 0x68bc21eb, ot);
        float jitter   = randfloat(i, p * 0x02e5be93);
        return (stratum + (subStratum + jitter) / stm) / s;
    }

    // Compute the digits of decimal value `i` expressed in base `b`
    vector<int> toBaseS(int i, int b, int t) {
        vector<int> digits(t);
        for (int ii = 0; ii < t; i /= b, ++ii)
        digits[ii] = i % b;
        return digits;
    }

    // Evaluate polynomial with coefficients a at location arg
    int evalPoly(const vector<int> & a, int arg) {
        int ans = 0;
        for (int l = a.size()-1; l >= 0; --l)
        ans = (ans * arg) + a[l];        // Horner's rule
        return ans;
    }

    // Compute substrata offsets
    int offset(int i, int s, int numSS, int p, OffsetType ot) {
        if (ot == J) return permute(0, numSS, (i + 1) * p);
        return permute((i / s) % numSS, numSS, p);  // Defaults to MJ
    }
\end{minted}

\noindent
Here we have the in-place implementation of Bush with jittered and
multi-jittered offsets. The functions \verb|evalPoly| and \verb|toBaseS|
correspond to Equation~\eqref{eq:bush-poly}, which we established is equivalent
to transforming the index to base $p$, and reinterpreting it in base 10.

\subsection{CMJND}

We constructed a generalization of Kensler's CMJ technique that relaxes the
constraint on the base that is present for the Bush and Bose construction
techniques and allows an arbitrary base that is not necessarily a prime number.
The downside to this method is that it constructs a full factorial design, an
orthogonal array where $t=d$, so the stratification is equal to the
dimensionality of the points (while still holding the N-rooks constraint). \\

We achieve this design by converting the index to base $p$, which essentially
gives us the selection of each stratum. We can permute these factors in order to
yield a random shuffling of the points. The trick here is to use the coefficient
for the current dimension (use the first coefficient to calculate a point in the
first dimension, and so on) to calculate the strata, and use the rest of the
coefficients to calculate the substrata. We have already established that this
strategy will create a unique selection of strata because the uniqueness of the
indices holds regardless of which base they are represented in.

\begin{minted}{cpp}
    float cmjdD(int i, int s, int t, int p) {
        int N          = pow(s, t);
        i              = permute(i, N, p * 0x51633e2d);
        auto iDigits   = toBaseS(i, s, t);
        int stm1       = N / s;     // s^(t-1)
        int stratum    = permute(iDigits[j], s, p);
        auto pDigits   = allButJ(iDigits, j);
        int subStratum = evalPoly(pDigits, s);
        subStratum     = permute(sstrata, stm1, p * 0x68bc21eb);
        float jitter   = randfloat(i, p * 0x02e5be93);
        return (stratum + (subStratum + jitter) / stm1) / s;
    }

    // Copy all but the j-th element of vector in
    vector<int> allButJ(const vector<int> & in, int omit) {
        vector<int> out(in.size()-1);
        copy(in.begin(), in.begin() + omit, out.begin());
        copy(in.begin() + omit + 1, in.end(), out.begin() + omit);
        return out;
    }
\end{minted}
